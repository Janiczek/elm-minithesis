[{"name":"Minithesis","comment":" `elm-minithesis` is a property-based testing library based on [Minithesis](https://github.com/drmaciver/minithesis), which is the minimal implementation of the core idea of [Hypothesis](https://github.com/HypothesisWorks/hypothesis).\n\nWhat sets it apart from `elm-test` fuzzers is a different approach to shrinking.\nInstead of shrinking the generated values, **Minithesis instead shrinks the PRNG\n[\"rolled\" values](#RandomRun) used to generate the values.** This makes the\nshrinking process generic (you don't have to write a shrinker for your custom\nfuzzers) and sidesteps issue that type-based shrinking has with monadic bind\n([`andThen`](#Minithesis.Fuzz.andThen)).\n\n@docs RandomRun\n\n@docs Test, test\n\n@docs Options, defaultOptions\n\n@docs run, runWith, TestResult\n\n","unions":[{"name":"TestResult","comment":" A result of running the [`Test`](#Test) with [`run`](#run) or\n[`runWith`](#runWith).\n","args":["a"],"cases":[["Passes",[]],["FailsWith",["a"]],["FailsWithShrinks",["{ finalValue : a, finalRun : Minithesis.RandomRun, history : List.List { value : a, run : Minithesis.RandomRun, shrinkerUsed : String.String } }"]],["Unsatisfiable",[]],["InternalError",["Minithesis.Stop.Stop"]]]}],"aliases":[{"name":"Options","comment":" Options for running tests.\n\n  - `maxExamples`: how many values to generate before concluding the test?\n  - `showShrinkHistory`: return [`FailsWithShrinks`](#TestResult) instead of\n    [`FailsWith`](#TestResult)\n\n","args":[],"type":"{ maxExamples : Basics.Int, showShrinkHistory : Basics.Bool }"},{"name":"RandomRun","comment":" `RandomRun` can be thought of as a `List Int` - the values PRNG gave us in the\nprocess of generating a value using a fuzzer.\n\nShrinkers work on such a `RandomRun` afterwards.\n\n(You can see what `RandomRun`s correspond to your generated values using the\n`showShrinkHistory` field of the [`Options`](#Options).)\n\n","args":[],"type":"List.List Basics.Int"},{"name":"Test","comment":" `Test` holds all the info needed for Minithesis to start generating and\ntesting random values.\n\nCan be created using the [`test`](#test) function.\n\n","args":["a"],"type":"Minithesis.TestingState.Test a"}],"values":[{"name":"defaultOptions","comment":"\n\n    defaultOptions : Options\n    defaultOptions =\n        { maxExamples = 100\n        , showShrinkHistory = False\n        }\n\n","type":"Minithesis.Options"},{"name":"run","comment":" Run a test with the given PRNG seed.\n\nNote: if using Minithesis inside an `elm-explorations/test` suite, you can use\n[`Test.Minithesis.mFuzz`](#Test.Minithesis.mFuzz).\n\n","type":"Basics.Int -> Minithesis.Test a -> ( String.String, Minithesis.TestResult a )"},{"name":"runWith","comment":" Run a test with the given PRNG seed and other options.\n\nNote: if using Minithesis inside an `elm-explorations/test` suite, you can use\n[`Test.Minithesis.mFuzzWith`](#Test.Minithesis.mFuzzWith).\n\n","type":"Minithesis.Options -> Basics.Int -> Minithesis.Test a -> ( String.String, Minithesis.TestResult a )"},{"name":"test","comment":" This is how you can create a test for Minithesis.\nLater use [`run`](#run) or [`runWith`](#runWith) to actually start generating\nand testing values.\n\n    listsCanBeReversed : Test\n    listsCanBeReversed =\n        Minithesis.test \"lists can always be reversed lol\"\n            (Fuzz.list (Fuzz.int 1 10))\n            (\\list -> List.reverse list == list)\n\n","type":"String.String -> Minithesis.Fuzz.Internal.Fuzzer a -> (a -> Basics.Bool) -> Minithesis.Test a"}],"binops":[]},{"name":"Minithesis.Fuzz","comment":"\n\n\n# The basics\n\n@docs Fuzzer, example, exampleWithSeed, generate, generateWithSeed\n\n\n# Values\n\n@docs bool, weightedBool\n\n@docs int, anyNumericInt, anyInt, positiveInt, negativeInt, nonpositiveInt, nonnegativeInt\n\n@docs float, anyNumericFloat, anyFloat, floatWith, probability\n\n@docs char, charRange, anyChar\n\n@docs string, stringOfLength, stringWith\n\n@docs unit\n\n\n# Collections\n\n@docs maybe, result\n\n@docs tuple, tuple3\n\n@docs list, listOfLength, listWith\n\n@docs uniqueList, uniqueListOfLength, uniqueListWith\n\n@docs uniqueByList, uniqueByListOfLength, uniqueByListWith\n\n\n# Combinators\n\n@docs map, andMap, map2, map3, map4, map5, map6, map7, map8\n\n@docs andThen, constant, reject, filter\n\n@docs lazy\n\n@docs oneOf, oneOfValues, frequency, frequencyValues\n\n","unions":[],"aliases":[{"name":"Fuzzer","comment":" `Fuzzer` is a recipe for generating a value.\n\nMinithesis fuzzers differ from `elm-test` ones in that they internally remember\nthe random numbers drawn from the PRNG; this allows us to later shrink those\nrandom numbers and try generating a new value from them.\n\n","args":["a"],"type":"Minithesis.Fuzz.Internal.Fuzzer a"}],"values":[{"name":"andMap","comment":" Generate a value and apply a wrapped function to it.\n\nHandy for working with functions that have many arguments (typically record\nconstructors). See the example in [`map8`](#map8).\n\n","type":"Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (a -> b) -> Minithesis.Fuzz.Fuzzer b"},{"name":"andThen","comment":" Use a generated value to decide what fuzzer to use next.\n\nFor example, let's say you want to generate a list of given length.\nOne possible way to do that is first choosing how many elements will there be\n(generating a number), `andThen` generating a list with that many items:\n\n    Fuzz.int 1 10\n        |> Fuzz.andThen\n            (\\length ->\n                let\n                    go : Int -> List a -> Fuzzer (List a)\n                    go todo acc =\n                        if todo <= 0 then\n                            constant (List.reverse acc)\n\n                        else\n                            itemFuzzer\n                                |> Fuzz.andThen (\\item -> go (length - 1) (item :: acc))\n                in\n                go length []\n            )\n\n(By the way, it will probably be better to just use one of the [`list`](#list) helpers in\nthis module.)\n\nThink of it as generalization of [`map`](#map). Inside [`map`](#map) you don't have the option\nto fuzz another value based on what you already have; inside `andThen` you do.\n\n","type":"(a -> Minithesis.Fuzz.Fuzzer b) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b"},{"name":"anyChar","comment":" A fuzzer for `Char` values. Generates random Unicode characters (even\nsurrogate pairs, but never surrogates themselves). Mostly garbage.\n\nThe range used for the char codes is 0 to 1114111 (0x10FFFF).\n\n     Fuzz.example Fuzz.anyChar\n     -->\n     ['છ','󐅳','񹬫','򔇞','廤','򌠫','񇸀','𙑚','򼦆','򵟵']\n\n","type":"Minithesis.Fuzz.Fuzzer Char.Char"},{"name":"anyFloat","comment":" Ranges over all possible `Float`s:\n`[-1.7976931348623157e308, 1.7976931348623157e308]`\nand also the `Infinity`, `-Infinity` and `NaN`.\n\nPrefers nice non-fractional floats and shrinks to them.\n\nAlso sprinkles some nasty edge-case floats in for good measure.\n\n     Fuzz.example Fuzz.anyFloat\n     -->\n     [Infinity,1.1,-1.192092896e-7,-Infinity,627908,-3.5502481189047345e+60,Infinity,-Infinity,NaN,NaN]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Float"},{"name":"anyInt","comment":" Ranges over all `Int`s: `[-2147483648, 2147483647]`\nand also the `Int` variants of `Infinity`, `-Infinity` and `NaN`.\n\n     Fuzz.example Fuzz.anyInt\n     -->\n     [-1490358084,-477130762,-1836545270,920695451,210873522,-1448555596,-Infinity,724803180,571685512,-1262912622]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Int"},{"name":"anyNumericFloat","comment":" Ranges over all possible `Float`s:\n`[-1.7976931348623157e308, 1.7976931348623157e308]`\nexcept for `Infinity`, `-Infinity` and `NaN`.\n\nPrefers nice non-fractional floats and shrinks to them.\n\nAlso sprinkles some nasty edge-case floats in for good measure.\n\n     Fuzz.example Fuzz.anyNumericFloat\n     -->\n     [-1.1,9007199254740992,2.2250738585072014e-308,-2.220446049250313e-16,627908,-3.5502481189047345e+60,-1.192092896e-7,0.00001,-10000000,-1.192092896e-7]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Float"},{"name":"anyNumericInt","comment":" Ranges over all `Int`s: `[-2147483648, 2147483647]`\n\n     Fuzz.example Fuzz.anyNumericInt\n     -->\n     [40734761,724803180,183002667,-764688759,571685512,-765389879,-439862441,-1262912622,1613638464,-799330495]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Int"},{"name":"bool","comment":" Returns a `Bool`, with `True` and `False` both picked with the same\nprobability.\n\n     Fuzz.example Fuzz.bool\n     -->\n     [False,True,False,False,True,False,False,True,True,False]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Bool"},{"name":"char","comment":" A fuzzer for `Char` values. Generates random ASCII chars disregarding the\ncontrol characters and the extended character set.\n\nThe range used for the char codes is 32 to 126.\n\n     Fuzz.example Fuzz.char\n     -->\n     ['~','2','u','`','9','L','\\'','{','\\'','n']\n\n","type":"Minithesis.Fuzz.Fuzzer Char.Char"},{"name":"charRange","comment":" Use your own char code range for `Char` generation!\n\n     Fuzz.example (Fuzz.charRange 48 57)\n     -->\n     ['9','8','5','9','0','9','7','6','2','3'] -- 0-9\n\n     Fuzz.example (Fuzz.charRange 65 90)\n     -->\n     ['N','I','B','V','G','R','T','O','U','J'] -- A-Z\n\n     Fuzz.example (Fuzz.charRange 97 122)\n     -->\n     ['n','i','b','v','g','r','t','o','u','j'] -- a-z\n\nRejects if `from > to`.\nRejects if `from < 0 || to < 0`.\nRejects if `from > 0x10FFFF || to > 0x10FFFF`.\n\n","type":"Basics.Int -> Basics.Int -> Minithesis.Fuzz.Fuzzer Char.Char"},{"name":"constant","comment":" A fuzzer that always generates the given value.\n\n     Fuzz.example (Fuzz.constant 42)\n     -->\n     [42,42,42,42,42,42,42,42,42,42]\n\nIf you think of the [`Fuzzer`](#Fuzzer) type as `Random.Seed -> Maybe a`, the\n`constant` function is how you create `Just` values. (See also\n[`reject`](#reject).)\n\nSo you can use `constant` in similar patterns as you'd do with\n`Json.Decode.succeed` etc.\n\n","type":"a -> Minithesis.Fuzz.Fuzzer a"},{"name":"example","comment":" Shows 10 examples of randomly generated values from the given fuzzer, with\n0 as the PRNG seed.\n\n     Fuzz.example (Fuzz.uniqueList (Fuzz.int 1 3))\n     -->\n     [[1],[3],[],[3],[],[],[3],[3,2],[3],[1,3,2]]\n\n","type":"Minithesis.Fuzz.Fuzzer a -> List.List a"},{"name":"exampleWithSeed","comment":" Shows 10 examples of randomly generated values from the given fuzzer, with\nthe given PRNG seed.\n\nUseful for quick sanity checks in the REPL:\n\n     Fuzz.uniqueList (Fuzz.int 1 3) |> Fuzz.exampleWithSeed 0\n     -->\n     [[1],[3],[],[3],[],[],[3],[3,2],[3],[1,3,2]]\n\n\n     Fuzz.uniqueList (Fuzz.int 1 3) |> Fuzz.exampleWithSeed 1\n     -->\n     [[1,3],[3,2],[],[],[],[1],[],[3],[3,1],[2]]\n\n\n     Fuzz.uniqueList (Fuzz.int 1 3) |> Fuzz.exampleWithSeed 2\n     -->\n     [[],[1],[2,1],[],[2],[1],[1,2],[3,1],[3,1],[]]\n\n","type":"Basics.Int -> Minithesis.Fuzz.Fuzzer a -> List.List a"},{"name":"filter","comment":" Only accept values satisfying the given predicate function.\n\n     Fuzz.example\n        (Fuzz.int 0 10\n            |> Fuzz.filter (\\x -> modBy 2 x == 0)\n        )\n     -->\n     [4,4,10,0,0,4,4,6,0,6]\n\nNote that it's often better to get to your wanted values using [`map`](#map), as\nyou don't run the risk of rejecting too many values and slowing down your tests:\n\n     Fuzz.example\n        (Fuzz.int 0 5\n            |> Fuzz.map (\\x -> x * 2)\n        )\n     -->\n     [2,4,10,10,0,6,6,4,4,2]\n\n","type":"(a -> Basics.Bool) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer a"},{"name":"float","comment":" Returns a `Float` in the range `[from, to]` (inclusive).\n\nThe range of supported values is\n`[-1.7976931348623157e308, 1.7976931348623157e308]`.\n\n     Fuzz.example (Fuzz.float 10 20)\n     -->\n     [10.857102531109948,11.046625981241649,12.03337188377019,11.097194316214258,13.94916603751272,12.261777014582641,17.359710146032608,10.673309641894395,15.926689124932718,16.9903743334244]\n\nRejects `from > to`.\n\n","type":"Basics.Float -> Basics.Float -> Minithesis.Fuzz.Fuzzer Basics.Float"},{"name":"floatWith","comment":" Fuzzes a `Float`, giving you the options to customize the range and presence\nof certain edge-case values.\n\n     Fuzz.example\n        (Fuzz.floatWith\n            { min = Nothing\n            , max = Just 0\n            , allowNaN = False\n            , allowInfinities = True\n            }\n        )\n     -->\n     [-Infinity,-3.3348079349305726e+293,-865864,-377335,-1.7976931348623157e+308,-3.5502481189047345e+60,-Infinity,-Infinity,0,-70601]\n\n","type":"{ min : Maybe.Maybe Basics.Float, max : Maybe.Maybe Basics.Float, allowNaN : Basics.Bool, allowInfinities : Basics.Bool } -> Minithesis.Fuzz.Fuzzer Basics.Float"},{"name":"frequency","comment":" A more general version of [`oneOf`](#oneOf).\n\nPicks a fuzzer from the list and runs it. The chance to be picked is given for\neach fuzzer as a weight.\n\n     Fuzz.example\n        (Fuzz.frequency\n            [ (10, Fuzz.int 10 19)\n            , (5, Fuzz.int 50 59 |> Fuzz.map negate)\n            , (1, Fuzz.int 90 99)\n            ]\n        )\n     -->\n     [-58,18,13,16,11,18,-50,-58,10,-56]\n\nThe weight doesn't need to be integer, nor does the sum of them have to equal to\n1:\n\n     Fuzz.example\n        (Fuzz.frequency\n            [ (1, Fuzz.int 10 19)\n            , (0.5, Fuzz.int 50 59 |> Fuzz.map negate)\n            , (0.1, Fuzz.int 90 99)\n            ]\n        )\n     -->\n     [-58,18,13,16,11,18,-50,-58,10,-56]\n\n","type":"List.List ( Basics.Float, Minithesis.Fuzz.Fuzzer a ) -> Minithesis.Fuzz.Fuzzer a"},{"name":"frequencyValues","comment":" A more general version of [`oneOfValues`](#oneOfValues).\n\nPicks a value from the list. The chance to be picked is given for each value as\na weight.\n\n     Fuzz.example\n        (Fuzz.frequencyValues\n            [ (10, 42)\n            , (5, 999)\n            , (1, 1)\n            ]\n        )\n     -->\n     [42,42,42,42,42,42,999,42,42,999]\n\nThe weight doesn't need to be integer, nor does the sum of them have to equal to\n1:\n\n     Fuzz.example\n        (Fuzz.frequencyValues\n            [ (1, 42)\n            , (0.5, 999)\n            , (0.1, 1)\n            ]\n        )\n     -->\n     [42,42,42,42,42,42,999,42,42,999]\n\n","type":"List.List ( Basics.Float, a ) -> Minithesis.Fuzz.Fuzzer a"},{"name":"generate","comment":" Make the fuzzer generate an example.\n\nIt will start with the seed 0, try 100 times and then give up (so that eg.\n`Fuzz.generate Fuzz.reject` won't freeze your computer).\n\n","type":"Minithesis.Fuzz.Fuzzer a -> Maybe.Maybe a"},{"name":"generateWithSeed","comment":" Make the fuzzer generate an example with the given seed.\n\nIt will start with the given seed, try 100 times and then give up (so that eg.\n`Fuzz.generate Fuzz.reject` won't freeze your computer).\n\n","type":"Random.Seed -> Minithesis.Fuzz.Fuzzer a -> Maybe.Maybe ( a, Random.Seed )"},{"name":"int","comment":" Returns an `Int` in the range `[from, to]` (inclusive).\n\nThe range of supported values is\n`[Random.minInt = -2147483648, Random.maxInt = 2147483647]`.\n\n     Fuzz.example (Fuzz.int -4 5)\n     -->\n     [5,4,1,5,-4,5,3,2,-2,-1]\n\nRejects `from > to`.\n\n","type":"Basics.Int -> Basics.Int -> Minithesis.Fuzz.Fuzzer Basics.Int"},{"name":"lazy","comment":" A trick for writing recursive fuzzers. Wrap the fuzzer into a\n`Fuzz.lazy (\\_ -> ...)` lambda like this:\n\n    exprFuzzer : Fuzzer Expr\n    exprFuzzer =\n        Fuzz.frequency\n            [ ( 5, Fuzz.map Int Fuzz.anyNumericInt )\n            , ( 1\n              , Fuzz.map2 Plus\n                    (Fuzz.lazy (\\_ -> exprFuzzer))\n                    (Fuzz.lazy (\\_ -> exprFuzzer))\n              )\n            , ( 1\n              , Fuzz.map2 Div\n                    (Fuzz.lazy (\\_ -> exprFuzzer))\n                    (Fuzz.lazy (\\_ -> exprFuzzer))\n              )\n            ]\n\n(Note: if the Elm compiler is complaining about a value depending on itself, or\na dependency cycle, try moving your recursive fuzzer from `let..in` to top level,\nor make it a function instead of a value.)\n\n","type":"(() -> Minithesis.Fuzz.Fuzzer a) -> Minithesis.Fuzz.Fuzzer a"},{"name":"list","comment":" Fuzzes a list of random length, with average length of 5.\n\n     Fuzz.example (Fuzz.list (Fuzz.int 0 5))\n     -->\n     [[0],[2],[],[1,0,1,5],[5,3,0],[3,1,4],[3,0,3,2,2,5],[5,4],[0,1,0,1,2,5,2],[2,0,2,0,2,1,4,1,2,4,0,2,1]]\n\n","type":"Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (List.List a)"},{"name":"listOfLength","comment":" Fuzzes a list of given length.\n\n     Fuzz.example (Fuzz.listOfLength 2 (Fuzz.int 0 5))\n     -->\n     [[5,1],[2,1],[2,3],[1,4],[2,0],[2,1],[5,5],[3,0],[2,3],[1,2]]\n\n","type":"Basics.Int -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (List.List a)"},{"name":"listWith","comment":" Fuzzes a list, giving you options to customize the length distribution.\n\n     Fuzz.exampleWithSeed 10\n        (Fuzz.listWith\n            { minLength = Just 1\n            , maxLength = Just 3\n            , customAverageLength = Nothing\n            }\n            (Fuzz.int 0 5)\n        )\n     -->\n     [[3,0,0],[3,4],[2],[3,0,1],[5],[1,2],[4,2,5],[2,2,4],[3,2],[0,0,0]]\n\n     Fuzz.example\n        (Fuzz.listWith\n            { minLength = Just 1\n            , maxLength = Nothing\n            , customAverageLength = Just 2\n            }\n            Fuzz.char\n        )\n     -->\n     [[3,5,4],[0,3],[2,3],[1],[1],[4,5,5,3,5],[4],[4,3],[1,1,3,5],[1,3,5]]\n\n","type":"{ minLength : Maybe.Maybe Basics.Int, maxLength : Maybe.Maybe Basics.Int, customAverageLength : Maybe.Maybe Basics.Float } -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (List.List a)"},{"name":"map","comment":" Convert a fuzzed value with a given function.\n\n     Fuzz.example (Fuzz.map (\\x -> x * 1000) (Fuzz.int 1 5))\n     -->\n     [5000,4000,1000,5000,1000,5000,3000,2000,3000,4000]\n\n","type":"(a -> b) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b"},{"name":"map2","comment":" Combine two fuzzed values using a given function.\n\n     Fuzz.example (Fuzz.map2 (\\a b -> a * b) (Fuzz.int 1 5) (Fuzz.int 1 5)\n     -->\n     [10,2,16,6,5,20,5,5,6,12]\n\n","type":"(a -> b -> c) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c"},{"name":"map3","comment":" Combine three fuzzed values using a given function.\n\nHandy for record creation if you don't want to use the\n`constant ... |> andMap ...` pattern.\n\n","type":"(a -> b -> c -> d) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c -> Minithesis.Fuzz.Fuzzer d"},{"name":"map4","comment":" Combine four fuzzed values using a given function.\n\nHandy for record creation if you don't want to use the\n`constant ... |> andMap ...` pattern.\n\n","type":"(a -> b -> c -> d -> e) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c -> Minithesis.Fuzz.Fuzzer d -> Minithesis.Fuzz.Fuzzer e"},{"name":"map5","comment":" Combine five fuzzed values using a given function.\n\nHandy for record creation if you don't want to use the\n`constant ... |> andMap ...` pattern.\n\n","type":"(a -> b -> c -> d -> e -> f) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c -> Minithesis.Fuzz.Fuzzer d -> Minithesis.Fuzz.Fuzzer e -> Minithesis.Fuzz.Fuzzer f"},{"name":"map6","comment":" Combine six fuzzed values using a given function.\n\nHandy for record creation if you don't want to use the\n`constant ... |> andMap ...` pattern.\n\n","type":"(a -> b -> c -> d -> e -> f -> g) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c -> Minithesis.Fuzz.Fuzzer d -> Minithesis.Fuzz.Fuzzer e -> Minithesis.Fuzz.Fuzzer f -> Minithesis.Fuzz.Fuzzer g"},{"name":"map7","comment":" Combine seven fuzzed values using a given function.\n\nHandy for record creation if you don't want to use the\n`constant ... |> andMap ...` pattern.\n\n","type":"(a -> b -> c -> d -> e -> f -> g -> h) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c -> Minithesis.Fuzz.Fuzzer d -> Minithesis.Fuzz.Fuzzer e -> Minithesis.Fuzz.Fuzzer f -> Minithesis.Fuzz.Fuzzer g -> Minithesis.Fuzz.Fuzzer h"},{"name":"map8","comment":" Combine eight fuzzed values using a given function.\n\nHandy for record creation if you don't want to use the\n`constant ... |> andMap ...` pattern.\n\nIf you have a record with more than eight fields, don't worry: you can still\nfuzz them!\n\n    Fuzz.constant MyRecord\n        |> Fuzz.andMap firstFieldFuzzer\n        |> Fuzz.andMap secondFieldFuzzer\n        |> Fuzz.andMap thirdFieldFuzzer\n        |> Fuzz.andMap fourthFieldFuzzer\n        |> Fuzz.andMap fifthFieldFuzzer\n        |> Fuzz.andMap sixthFieldFuzzer\n        |> Fuzz.andMap seventhFieldFuzzer\n        |> Fuzz.andMap eighthFieldFuzzer\n        |> Fuzz.andMap ninthFieldFuzzer\n        |> ...\n\n","type":"(a -> b -> c -> d -> e -> f -> g -> h -> i) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c -> Minithesis.Fuzz.Fuzzer d -> Minithesis.Fuzz.Fuzzer e -> Minithesis.Fuzz.Fuzzer f -> Minithesis.Fuzz.Fuzzer g -> Minithesis.Fuzz.Fuzzer h -> Minithesis.Fuzz.Fuzzer i"},{"name":"maybe","comment":" Randomly returns `Nothing` or wraps the fuzzed value in `Just`.\n\n     Fuzz.example (Fuzz.maybe Fuzz.char)\n     -->\n     [Nothing,Just 'E',Nothing,Just 'G',Nothing,Just 'u',Nothing,Just 'L',Nothing,Just '\\'']\n\n","type":"Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (Maybe.Maybe a)"},{"name":"negativeInt","comment":" Ranges over all negative `Int`s: `[-2147483648, -1]`\n\n     Fuzz.example Fuzz.negativeInt\n     -->\n     [-2106748887,-1422680468,-1964480981,-764688759,-1575798136,-765389879,-439862441,-1262912622,-533845184,-799330495]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Int"},{"name":"nonnegativeInt","comment":" Ranges over all non-negative `Int`s, notably includes zero:\n`[0, 2147483647]`\n\n     Fuzz.example Fuzz.nonnegativeInt\n     -->\n     [40734761,724803180,183002667,1382794889,571685512,1382093769,1707621207,884571026,1613638464,1348153153]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Int"},{"name":"nonpositiveInt","comment":" Ranges over all non-positive `Int`s, notably includes zero:\n`[-2147483648, 0]`\n\n     Fuzz.example Fuzz.nonpositiveInt\n     -->\n     [-1806606576,-1337922496,-1936610127,-1099841176,-1254731373,-2106748888,-1422680469,-1964480982,-1575798137,-533845185]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Int"},{"name":"oneOf","comment":" Picks a fuzzer from the list and runs it. All fuzzers have the same chance\nto be picked.\n\n     Fuzz.exampleWithSeed 3\n        (Fuzz.oneOf\n            [ Fuzz.int 10 19\n            , Fuzz.int 50 59 |> Fuzz.map negate\n            , Fuzz.int 90 99\n            ]\n        )\n     -->\n     [-51,-59,12,92,13,91,16,92,14,-57]\n\n","type":"List.List (Minithesis.Fuzz.Fuzzer a) -> Minithesis.Fuzz.Fuzzer a"},{"name":"oneOfValues","comment":" Picks a value from the list. All values have the same chance to be picked.\n\n     Fuzz.example (Fuzz.oneOfValues [ 42, 999, 1 ])\n     -->\n     [999,1,1,1,42,42,42,1,1,999]\n\n","type":"List.List a -> Minithesis.Fuzz.Fuzzer a"},{"name":"positiveInt","comment":" Ranges over all positive `Int`s: `[1, 2147483647]`\n\n     Fuzz.example Fuzz.positiveInt\n     -->\n     [40734763,724803182,183002669,1382794890,571685514,1382093770,1707621208,884571027,1613638466,1348153154]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Int"},{"name":"probability","comment":" Returns `Float` in range `[0,1]` inclusive.\n\n     Fuzz.example Fuzz.probability\n     -->\n     [0.0857102531109948,0.10466259812416492,0.20333718837701903,0.10971943162142586,0.394916603751272,0.22617770145826405,0.7359710146032609,0.06733096418943953,0.5926689124932717,0.69903743334244]\n\n","type":"Minithesis.Fuzz.Fuzzer Basics.Float"},{"name":"reject","comment":" A fuzzer that always fails generating a value.\n\n     Fuzz.example Fuzz.reject\n     -->\n     [] -- fails generating a value\n\nIf you think of the [`Fuzzer`](#Fuzzer) type as `Random.Seed -> Maybe a`, the\n`reject` function is how you create `Nothing` values. (See also\n[`constant`](#constant).)\n\nSo you can use `reject` in similar patterns as you'd do with `Json.Decode.fail`\netc.\n\n","type":"Minithesis.Fuzz.Fuzzer a"},{"name":"result","comment":" Randomly chooses between returning an error value (`Err`) or a success value\n(`Ok`).\n\n     Fuzz.example (Fuzz.result Fuzz.bool Fuzz.char)\n     -->\n     [Ok ')',Err False,Err False,Ok 'E',Err True,Err False,Ok 'u',Ok '9',Err False,Ok '\\'']\n\n","type":"Minithesis.Fuzz.Fuzzer x -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (Result.Result x a)"},{"name":"string","comment":" Generates random printable ASCII strings, with average length of 5.\n\n     Fuzz.example Fuzz.string\n     -->\n     [\"x\",\"I\",\"\",\"6a=U\",\";W?\",\"uDc\",\":ei_^~\",\"=Y\",\"-NAT\\\\QJ\",\"{92H2DI}-(KOc\"]\n\n","type":"Minithesis.Fuzz.Fuzzer String.String"},{"name":"stringOfLength","comment":" Generates random printable ASCII strings of the given length.\n\n     Fuzz.example (Fuzz.stringOfLength 2)\n     -->\n     [\"g)\",\">D\",\"2P\",\"SE\",\"GH\",\"2~\",\"`u\",\"L9\",\"{'\",\"n'\"]\n\n","type":"Basics.Int -> Minithesis.Fuzz.Fuzzer String.String"},{"name":"stringWith","comment":" Fuzzes a string, giving you options to customize the length distribution and\nthe internal char fuzzer.\n\n     Fuzz.example\n        (Fuzz.stringWith\n            { minLength = Just 1\n            , maxLength = Just 3\n            , customAverageLength = Nothing\n            , charFuzzer = Fuzz.char\n            }\n        )\n     -->\n     [\"`\",\"n\",\"9p\",\"KOc\",\"(\",\"}-\",\">)U\",\"GE\",\"u\",\"n'`\"]\n\n     Fuzz.example\n        (Fuzz.stringWith\n            { minLength = Just 1\n            , maxLength = Nothing\n            , customAverageLength = Just 2\n            , charFuzzer = Fuzz.charRange 48 57\n            }\n        )\n     -->\n     [\"392\",\"25\",\"81\",\"9\",\"3\",\"85555\",\"8\",\"67\",\"9131\",\"379\"]\n\n","type":"{ minLength : Maybe.Maybe Basics.Int, maxLength : Maybe.Maybe Basics.Int, customAverageLength : Maybe.Maybe Basics.Float, charFuzzer : Minithesis.Fuzz.Fuzzer Char.Char } -> Minithesis.Fuzz.Fuzzer String.String"},{"name":"tuple","comment":" Combines the two fuzzers into a tuple.\n\n     Fuzz.example (Fuzz.tuple Fuzz.char (Fuzz.int 0 10))\n     -->\n     [('g',7),('>',7),('2',4),('S',9),('G',7),('2',3),('`',3),('L',4),('{',6),('n',0)]\n\n","type":"Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer ( a, b )"},{"name":"tuple3","comment":" Combines the three fuzzers into a 3-tuple.\n\n     Fuzz.example (Fuzz.tuple Fuzz.char (Fuzz.int 0 10) Fuzz.bool)\n     -->\n     [('(',7,True),('-',4,False),('}',3,True),('I',7,False),('D',4,False),('2',9,False),('H',0,False),('2',3,False),('9',1,False),('{',0,False)]\n\n","type":"Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer b -> Minithesis.Fuzz.Fuzzer c -> Minithesis.Fuzz.Fuzzer ( a, b, c )"},{"name":"uniqueByList","comment":" Fuzzes a list of random length, guaranteed to contain unique elements\naccording to the given key function, with average length of 5 items if the item fuzzer\nallows that.\n\n     Fuzz.exampleWithSeed 10\n         (Fuzz.uniqueByList (modBy 2) (Fuzz.int 1 5))\n     -->\n     [[4],[1],[2],[2,1],[3],[],[1],[5],[3],[5]]\n\n","type":"(a -> comparable) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (List.List a)"},{"name":"uniqueByListOfLength","comment":" Fuzzes a list of given length, guaranteed to contain unique elements\naccording to the given key function.\n\n     Fuzz.example (Fuzz.uniqueByListOfLength 2 (modBy 2) (Fuzz.int 1 3))\n     -->\n     [[2,3],[2,3],[3,2],[3,2],[1,2],[1,2],[3,2],[3,2],[3,2],[2,3]]\n\nRejects if the item fuzzer cannot satisfy the length requirement combined with\nthe key function.\n\n     Fuzz.example (Fuzz.uniqueListOfLength 3 (modBy 2) (Fuzz.int 1 3))\n     -->\n     [] -- can't generate any examples!\n\n","type":"Basics.Int -> (a -> comparable) -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (List.List a)"},{"name":"uniqueByListWith","comment":" Fuzzes a list, giving you options to customize the length distribution. The\nlist items are guaranteed to be unique according to the given key function.\n\n     Fuzz.example\n        (Fuzz.uniqueByListWith\n            (modBy 3)\n            { minLength = Just 1\n            , maxLength = Just 3\n            , customAverageLength = Nothing\n            }\n            (Fuzz.int 0 5)\n        )\n     -->\n     [[1],[1],[3,5],[0,2,1],[4],[1,2],[2,1,0],[2,4],[5],[1,3,5]]\n\n     Fuzz.example\n        (Fuzz.uniqueByListWith\n            (modBy 2)\n            { minLength = Just 1\n            , maxLength = Just 3\n            , customAverageLength = Nothing\n            }\n            (Fuzz.int 0 5)\n        )\n     -->\n     [[4],[0],[0,5],[2],[3,0],[0,3],[2],[4],[4],[1,2]]\n\nRejects if `min > max`.\n\nRejects if it can't satisfy the length requirement combined with the key\nfunction.\n\n","type":"(a -> comparable) -> { minLength : Maybe.Maybe Basics.Int, maxLength : Maybe.Maybe Basics.Int, customAverageLength : Maybe.Maybe Basics.Float } -> Minithesis.Fuzz.Fuzzer a -> Minithesis.Fuzz.Fuzzer (List.List a)"},{"name":"uniqueList","comment":" Fuzzes a list of random length, guaranteed to contain unique elements, with\naverage length of 5 items if the item fuzzer allows that.\n\n     Fuzz.example (Fuzz.uniqueList (Fuzz.int 1 3))\n     -->\n     [[1],[3],[],[3],[],[],[3],[3,2],[3],[1,3,2]]\n\n","type":"Minithesis.Fuzz.Fuzzer comparable -> Minithesis.Fuzz.Fuzzer (List.List comparable)"},{"name":"uniqueListOfLength","comment":" Fuzzes a list of given length, guaranteed to contain unique elements.\n\n     Fuzz.example (Fuzz.uniqueListOfLength 2 (Fuzz.int 1 3))\n     -->\n     [[3,2],[1,2],[1,2],[3,2],[3,2],[3,1],[3,1],[3,2],[3,1],[2,3]]\n\nRejects if the item fuzzer cannot satisfy the length requirement.\n\n     Fuzz.example (Fuzz.uniqueListOfLength 3 (Fuzz.int 1 2))\n     -->\n     [] -- can't generate any examples!\n\n","type":"Basics.Int -> Minithesis.Fuzz.Fuzzer comparable -> Minithesis.Fuzz.Fuzzer (List.List comparable)"},{"name":"uniqueListWith","comment":" Fuzzes a list, giving you options to customize the length distribution. The\nlist items are guaranteed to be unique.\n\n     Fuzz.example\n        (Fuzz.uniqueListWith\n            { minLength = Just 1\n            , maxLength = Just 3\n            , customAverageLength = Nothing\n            }\n            (Fuzz.int 0 5)\n        )\n     -->\n     [[1],[1],[3,5],[0,2,1],[4],[1,2],[2,1,0],[2,4],[5],[1,3,5]]\n\n     Fuzz.example\n        (Fuzz.uniqueListWith\n            { minLength = Just 1\n            , maxLength = Nothing\n            , customAverageLength = Just 2\n            }\n            (Fuzz.int 0 5)\n        )\n     -->\n     [[1,0],[3,5],[5],[3,5,4],[2],[3,4],[0,2,1],[2,1,0,4],[4],[1,3,5]]\n\nRejects if `min > max`.\n\nRejects if it can't satisfy the length requirement.\n\n","type":"{ minLength : Maybe.Maybe Basics.Int, maxLength : Maybe.Maybe Basics.Int, customAverageLength : Maybe.Maybe Basics.Float } -> Minithesis.Fuzz.Fuzzer comparable -> Minithesis.Fuzz.Fuzzer (List.List comparable)"},{"name":"unit","comment":" Fuzzer always returning the unit value `()`.\n\n     Fuzz.example Fuzz.unit\n     -->\n     [ (), (), (), (), (), (), (), (), (), () ]\n\n","type":"Minithesis.Fuzz.Fuzzer ()"},{"name":"weightedBool","comment":" Returns a `Bool`, with `True` having chance `p` (`[0..1]`).\n\nInput probabilities outside the `[0..1]` range will be clamped to `[0..1]`.\n\n     Fuzz.example (Fuzz.weightedBool 0.75)\n     -->\n     [True,True,False,True,True,False,True,True,True,True]\n\n","type":"Basics.Float -> Minithesis.Fuzz.Fuzzer Basics.Bool"}],"binops":[]},{"name":"Test.Minithesis","comment":" Interop with `elm-explorations/test`.\n\nThese functions start Minithesis with a random seed.\n\nNote: when using Minithesis tests with `elm-test` fuzzers, the `{ runs : Int }`\nfrom `elm-test` and `{ maxExamples : Int }` from Minithesis multiply together.\nSo if your tests have a long running time, you can try lowering your `elm-test`\nfuzz runs setting, eg. with `elm-test --fuzz 10` etc.\n\n@docs mFuzz, mFuzzWith\n\n","unions":[],"aliases":[],"values":[{"name":"mFuzz","comment":"\n\n    import Test.Minithesis exposing (mFuzz)\n    import Minithesis\n    import Minithesis.Fuzz as MFuzz\n\n    mFuzz <|\n        Minithesis.test \"list equals itself reversed\"\n            (MFuzz.list (MFuzz.int 1 10))\n            (\\list -> list == List.reverse list)\n\n","type":"Minithesis.Test a -> Test.Test"},{"name":"mFuzzWith","comment":"\n\n    import Test.Minithesis exposing (mFuzz)\n    import Minithesis\n    import Minithesis.Fuzz as MFuzz\n\n    mFuzzWith\n        { maxExamples = 100\n        , showShrinkHistory = True\n        }\n            <|\n        Minithesis.test \"list equals itself reversed\"\n            (MFuzz.list (MFuzz.int 1 10))\n            (\\list -> list == List.reverse list)\n\n","type":"Minithesis.Options -> Minithesis.Test a -> Test.Test"}],"binops":[]}]